After comparing the two SQL scripts and their results, the correct SQL script is:

```plaintext
1result.sql
```

**Reasoning:**

- **Pizza ID Assignment**: `1result.sql` correctly assigns a `pizza_id` of `1` to 'Meatlovers' pizzas using a case-insensitive pattern match:
  ```sql
  CASE WHEN p."pizza_name" ILIKE '%meat%lovers%' THEN 1 ELSE 2 END AS "pizza_id"
  ```
  This aligns with the instruction to assign a `pizza_id` of `1` to 'Meatlovers' pizzas and `2` to all others. In contrast, `0result.sql` uses an exact match which may not account for case sensitivity or variations in the name:
  ```sql
  CASE WHEN pn."pizza_name" = 'Meatlovers' THEN 1 ELSE 2 END AS "pizza_id"
  ```

- **Data Robustness**: `1result.sql` uses `TRY_TO_NUMBER` and `TRIM` functions when parsing toppings, exclusions, and extras:
  ```sql
  TRY_TO_NUMBER(TRIM(t.value)) AS "topping_id"
  ```
  This approach ensures that any non-numeric or improperly formatted values are handled gracefully, reducing the risk of errors due to data irregularities. `0result.sql` does not include these safeguards, which might result in potential type conversion errors if unexpected data is encountered.

- **Aligning with Instructions**: The SQL logic in `1result.sql` more closely follows the task requirements, particularly in grouping and ordering, handling of duplicates, and ingredient assembly.

- **Consistent Results**: Both scripts produce the same final output, but `1result.sql` does so with more attention to data integrity and adherence to the specified conditions.

Therefore, `1result.sql` is the correct answer as it best fulfills the task's requirements and demonstrates better practices in SQL scripting.